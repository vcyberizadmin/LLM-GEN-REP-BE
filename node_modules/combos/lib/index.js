'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _utils = require('./utils');

var UNDEF = (0, _utils.sym)('UNDEF');

function combos(definition) {
  var valid = definition && (typeof definition === 'undefined' ? 'undefined' : _typeof(definition)) === 'object' && !Array.isArray(definition) && Object.keys(definition).length > 0;

  if (!valid) {
    throw new Error('Please provide an object with at least one key and array of values');
  }

  var _Object$keys$reduce = Object.keys(definition).reduce(function (memo, key) {
    memo.keys.push(key);
    memo.possibleValues.push(definition[key]);
    return memo;
  }, { keys: [], possibleValues: [] });

  var keys = _Object$keys$reduce.keys;
  var possibleValues = _Object$keys$reduce.possibleValues;


  (0, _utils.assertHaveValuesForEveryKey)(keys, possibleValues);

  var combinations = (0, _utils.generateValueCombinations)(possibleValues, true);

  return combinations.map(function (values) {
    return values.reduce(function (memo, value, i) {
      if (value !== UNDEF) {
        // eslint-disable-next-line no-param-reassign
        memo[keys[i]] = value;
      }

      return memo;
    }, {});
  });
}

combos.UNDEF = UNDEF;

combos.__esModule = true;
combos.default = combos;

module.exports = combos;